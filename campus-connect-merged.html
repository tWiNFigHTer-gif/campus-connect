<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CampusConnect - Multi-Floor Navigation</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&icon_names=close" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&icon_names=search" />
    <script src="https://unpkg.com/@panzoom/panzoom@4.5.1/dist/panzoom.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background-color: #F5F5F5;
            font-family: Arial, sans-serif;
            margin: 0px;
            height: auto;
            overflow-x: hidden;
        }
        
        /* Loading Screen */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            font-size: 18px;
            color: #333;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #007BFF;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Top Navigation Section */
        .top-section {
            align-items: center;
            display: flex;
            justify-content: space-between;
            padding: 10px 15px;
            background: #F5F5F5;
        }

        .head {
            font-size: 18px;
            color: black;
            font-weight: 600;
        }

        nav ul {
            width: 100%;
            display: flex;
            list-style: none;
            justify-content: flex-end;
            align-items: center;
        }

        nav li {
            height: 50px;
        }

        nav a {
            height: 100%;
            padding: 0 30px;
            text-decoration: none;
            display: flex;
            align-items: center;
            color: black;
            transition: background-color 0.3s;
        }

        nav a:hover {
            background-color: #f0f0f0;
        }

        .hideonMobile {
            display: flex;
        }

        .menu {
            display: none;
            height: 30px;
            width: 30px;
            cursor: pointer;
            font-size: 20px;
            text-align: center;
            line-height: 30px;
        }

        .menu:active {
            opacity: 0.8;
            -webkit-tap-highlight-color: transparent;
            color: #007BFF;
        }

        #menuToggle a {
            font-size: 20px;
            font-weight: bold;
            color: #333;
            padding: 0 15px;
        }

        /* Sidebar for mobile */
        .sidebar {
            margin-top: 60px;
            position: fixed;
            top: 0;
            right: 0;
            height: 200px;
            width: 170px;
            z-index: 1001;
            border-radius: 10px;
            background-color: #f0f0f0;
            box-shadow: -10px 0 10px rgba(0,0,0,0.2);
            display: none;
            flex-direction: column;
            align-items: flex-start;
            justify-content: flex-start;
        }

        .sidebar li {
            margin-top: 0px;
            width: 100%;
        }

        .floor {
            transition: opacity 0.8s, background-color 0.8s;
            font-size: 15px;
            font-weight: 500;
        }

        .sidebar a {
            width: 100%;
            transition: background-color 0.3s;
            margin-right: 0;
        }

        .sidebar a:active {
            background-color: #dcdcdc;
        }

        /* Search Bar */
        .search-bar {
            position: relative;
            display: flex;
            width: max-content;
            align-items: center;
            padding: 14px;
            border-radius: 30px;
            background-color: #FFFFFF;
            margin-left: 15px;
            box-shadow: 1px 1px 5px rgba(0,0,0,0.2);
            transition: box-shadow 0.25s;
        }

        .search-bar:focus-within {
            box-shadow: 0 0 2px rgba(0,0,0,0.75);
        }

        .search-field {
            font-size: 16px;
            font-family: sans-serif;
            color: #333333;
            margin-left: 14px;
            outline: none;
            border: none;
            background: transparent;
            display: flex;
            width: 296px;
        }

        .search {
            color: #6C757D;
        }

        /* Map Section */
        .map {
            position: relative;
            display: inline-block;
            margin-top: 35px;
            width: 100%;
            overflow: hidden;
            border-radius: 1px;
        }

        #svg-container {
            width: 100%;
            height: 400px;
            position: relative;
            overflow: hidden;
            background: white;
            display: block;
        }

        .map-svg {
            width: 100% !important;
            height: 100% !important;
            display: block;
            cursor: grab;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            pointer-events: auto;
            position: absolute;
            top: 0;
            left: 0;
        }

        .map-svg:active {
            cursor: grabbing;
        }

        /* Button Section Below Map */
        .button-div {
            width: 100%;
            background-color: white;
            height: 80px;
            margin-top: -5px;
            display: inline-flex;
            justify-content: space-between;
        }

        #openDirections {
            margin: 10px 12px 10px 12px;
            padding: 11px 14px;
            background: #003366;
            border: none;
            color: white;
            border-radius: 13px;
            cursor: pointer;
        }

        .next-floor {
            margin: 20px 15px;
        }

        .next {
            margin-left: 5px;
            background: rgb(241, 241, 241);
            padding: 5px 5px;
            color: rgba(2, 2, 2, 0.67);
            border-radius: 2px;
            border: none;
            cursor: pointer;
            transition: background-color 0.5s;
        }

        .previous {
            background: rgb(241, 241, 241);
            padding: 5px 5px;
            color: rgba(2, 2, 2, 0.67);
            border-radius: 2px;
            border: none;
            cursor: pointer;
            transition: background-color 0.5s;
        }

        .next:hover, .previous:hover {
            background-color: #dddddda7;
        }

        .next:active, .previous:active {
            background-color: #dddddda7;
        }

        /* Line Divider */
        .line {
            margin-top: 20px;
            height: 0.6px;
            background-color: rgb(211, 211, 211);
        }

        /* Explore Section */
        .explore {
            margin-top: 35px;
        }

        .heading {
            text-align: center;
            font-size: 23px;
            font-weight: bold;
        }

        .buttons {
            display: flex;
            margin-top: 40px;
            gap: 10px;
            padding: 10px 15px;
            justify-content: space-evenly;
        }

        .buttons button {
            background-color: #007BFF;
            border-radius: 100px;
            border: none;
            width: 70px;
            height: 55px;
            box-shadow: 3px 5px 9px rgba(0,0,0,0.2);
            transition: opacity 0.85s;
            cursor: pointer;
        }

        .buttons button:hover {
            opacity: 0.8;
        }

        .buttons button:active {
            opacity: 0.8;
            -webkit-tap-highlight-color: transparent;
        }

        .buttons img {
            width: 25px;
            height: 25px;
            align-items: center;
        }

        .group-1, .group-2, .group-3 {
            display: flex;
            flex-direction: column;
        }

        .label-1, .label-2, .label-3 {
            margin-top: 10px;
            color: rgba(0, 0, 0, 0.7);
            font-weight: 500;
            font-size: 15px;
        }

        .label-1 {
            margin-left: 16px;
        }

        .label-2 {
            margin-left: -3px;
        }

        .label-3 {
            margin-left: 6px;
        }

        .buttons a {
            text-decoration: none;
            color: rgba(0, 0, 0, 0.697);
        }

        /* Directions Panel */
        .directions-panel {    
            position: fixed; 
            top: 0;
            left: -450px;
            width: 400px; 
            height: 100%;
            background: white;
            box-shadow: 2px 0 6px rgba(0,0,0,0.2);
            transition: left 0.3s ease;
            display: flex;
            flex-direction: column;
            z-index: 1002;
        }

        .directions-panel.open {
            left: 0; 
        }

        .back-button {
            padding: 15px;
            border-bottom: 1px solid #eee;
        }

        .back {
            width: 50px;
            background: transparent;
            border: none;
            margin-top: 15px;
            cursor: pointer;
        }

        .inputs {
            padding: 20px;
            position: relative;
        }

        .input-container {
            position: relative;
            margin-bottom: 15px;
        }

        .inputs input {
            width: 340px;
            padding: 10px;
            margin-top: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-bottom: 10px;
            position: relative;
        }

        .find {
            padding: 14px 130px;
            background-color: #007BFF;
            border: none;
            display: block;
            color: white;
            border-radius: 7px;
            font-size: 14px;
            margin: 25px 15px 0px;
            transition: opacity 0.8s;
            cursor: pointer;
        }

        .clear {
            padding: 14px 128px;
            background-color: rgb(241, 241, 241);
            border: none;
            display: block;
            color: rgba(2, 2, 2, 0.67);
            border-radius: 7px;
            font-size: 14px;
            margin: 12px 15px;
            transition: background-color 0.6s;
            cursor: pointer;
        }

        .find:hover {
            opacity: 0.8;
        }

        .clear:hover {
            background-color: #dddddda7;
        }

        /* Search Suggestions Dropdown */
        .suggestions-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border-radius: 16px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.2);
            max-height: 300px;
            overflow-y: auto;
            z-index: 1001;
            display: none;
            border: 1px solid #e0e0e0;
            margin-top: 8px;
            backdrop-filter: blur(10px);
        }

        .suggestion-item {
            padding: 14px 18px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
        }

        .suggestion-item:hover,
        .suggestion-item.selected {
            background-color: #f8f9fa;
        }

        .suggestion-item:last-child {
            border-bottom: none;
            border-radius: 0 0 16px 16px;
        }

        .suggestion-item:first-child {
            border-radius: 16px 16px 0 0;
        }

        .suggestion-icon {
            margin-right: 12px;
            font-size: 18px;
            color: #6C757D;
        }

        .suggestion-text {
            flex: 1;
        }

        .suggestion-category {
            font-size: 12px;
            color: #999;
            text-transform: uppercase;
        }

        /* Panel-specific dropdown styles */
        .input-container .suggestions-dropdown {
            position: absolute;
            top: calc(100% - 10px);
            left: 0;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            max-height: 250px;
            overflow-y: auto;
            z-index: 2000;
            display: none;
            border: 1px solid #ddd;
            width: 360px;
        }

        .input-container .suggestions-dropdown .suggestion-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
        }

        .input-container .suggestions-dropdown .suggestion-item:hover,
        .input-container .suggestions-dropdown .suggestion-item.selected {
            background-color: #e3f2fd;
        }

        .input-container .suggestions-dropdown .suggestion-item:last-child {
            border-bottom: none;
        }

        /* Status Display */
        #status {
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            margin: 10px 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            font-size: 14px;
            color: #333;
        }

        /* SVG Styles */
        .node {
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .node:hover {
            filter: brightness(1.2);
        }

        .path-line {
            fill: none;
            stroke: #007BFF;
            stroke-width: 8;
            stroke-linecap: round;
            stroke-linejoin: round;
            opacity: 0.8;
            filter: drop-shadow(0 0 10px rgba(0, 123, 255, 0.5));
        }

        .traveling-icon-group {
            filter: drop-shadow(0 0 15px rgba(255, 107, 53, 0.7));
        }

        /* Node Label */
        .node-label {
            position: fixed;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            pointer-events: none;
            z-index: 1000;
            white-space: nowrap;
            transform: translate(-50%, -100%);
            margin-top: -10px;
        }

        .node-label::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            border: 5px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.9);
            transform: translateX(-50%);
        }

        /* Zone Info Box */
        #zone-info-box {
            position: fixed;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(15px);
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 320px;
            min-width: 280px;
            display: none;
            z-index: 1000;
            font-family: Arial, sans-serif;
            animation: infoBoxSlideIn 0.3s ease-out;
        }

        @keyframes infoBoxSlideIn {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        /* Zone Info Box Button Hover Effects */
        #zone-info-box button {
            transition: all 0.2s ease;
        }

        #zone-info-box button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        #zone-info-box #navigate-to-btn:hover {
            background: #218838 !important;
        }

        #zone-info-box #set-destination-btn:hover {
            background: #0056b3 !important;
        }

        #zone-info-box #set-start-btn:hover {
            background: #138496 !important;
        }

        #zone-info-box #close-info-btn:hover {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 50%;
        }

        @keyframes zoneHighlightPulse {
            0%, 100% {
                fill-opacity: 0.3;
                stroke-opacity: 0.6;
            }
            50% {
                fill-opacity: 0.8;
                stroke-opacity: 1;
            }
        }

        /* Error Display */
        #error-display {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #e74c3c;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.3);
            z-index: 1001;
            display: none;
            max-width: 90%;
            text-align: center;
        }

        /* Responsive Design */
        @media (max-width: 800px) {
            .hideonMobile {
                display: none;
            }
            
            .menu {
                display: block;
            }
        }

        @media (min-width: 800px) {
            #menuToggle {
                display: none;
            }
        }

        /* Mobile: when width ‚â§ 576px */
        @media (max-width: 576px) {
            .search-bar {
                width: 90%;
                margin: 10px auto;
                padding: 10px;
            }
            
            .search-field {
                width: 100%;
                font-size: 14px;
            }
        }

        /* Tablet: between 577px and 800px */
        @media (min-width: 577px) {
            .search-bar {
                width: 70%;
                margin: 15px auto;
                padding: 12px;
            }
            
            .search-field {
                width: 100%;
                font-size: 15px;
            }
        }

        @media (max-width: 400px) {
            .directions-panel {
                width: 380px;
            }
            
            .inputs input {
                width: 300px;
            }
            
            .find, .clear {
                font-size: 12px;
                margin-left: 4px;
            }
            
            #zone-info-box {
                max-width: 90vw;
                min-width: auto;
                left: 5vw !important;
                top: 50% !important;
                transform: translateY(-50%) !important;
            }
        }
        /* Animations */
        @keyframes zoneHighlight {
            0%, 100% { 
                fill-opacity: 0.3;
                stroke-width: 2;
            }
            50% { 
                fill-opacity: 0.8;
                stroke-width: 4;
            }
        }

        @keyframes pulse {
            0%, 100% { 
                opacity: 1; 
                box-shadow: 0 0 0 0 rgba(0, 255, 0, 0.7);
            }
            50% { 
                opacity: 0.8; 
                box-shadow: 0 0 0 10px rgba(0, 255, 0, 0);
            }
        }

        @keyframes navigation-pulse {
            0%, 100% { 
                opacity: 0.3;
                transform: scale(1);
            }
            50% { 
                opacity: 0.6;
                transform: scale(1.2);
            }
        }

        @keyframes path-draw {
            0% { 
                stroke-dasharray: 0 1000;
            }
            100% { 
                stroke-dasharray: 1000 0;
            }
        }

        .navigation-icon {
            transition: transform 0.3s ease-out;
        }

        .path-segment {
            animation: path-draw 0.5s ease-out forwards;
        }

        .start-node-pulse {
            animation: pulse 1s infinite;
            transform-origin: center center;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <div id="loadingText">Loading Campus Connect...</div>
    </div>
    
    <div id="error-display"></div>
    
    <!-- Top Navigation Section -->
    <div class="top-section">
        <p class="head">CampusConnect</p>
        <nav>
            <ul class="sidebar">
                <li class="floor"><a href="#" data-floor="G">Ground Floor</a></li>
                <li class="floor"><a href="#" data-floor="1">Floor 1</a></li>
                <li class="floor"><a href="#" data-floor="2">Floor 2</a></li>
                <li class="floor"><a href="#" data-floor="3">Floor 3</a></li>
                <li class="floor"><a href="#" data-floor="4">Floor 4</a></li>
            </ul>
            <ul>
                <li class="hideonMobile"><a href="#" data-floor="1">Floor 1</a></li>
                <li class="hideonMobile"><a href="#" data-floor="2">Floor 2</a></li>
                <li class="hideonMobile"><a href="#" data-floor="3">Floor 3</a></li>
                <li class="hideonMobile"><a href="#" data-floor="4">Floor 4</a></li>
                <li id="menuToggle"><a href="#">‚ò∞</a></li>
            </ul>
        </nav>
    </div>

    <!-- Search Bar -->
    <div class="search-bar">
        <span class="search material-symbols-outlined">search</span>
        <input type="search" 
               id="searchField" 
               placeholder="Search class, departments" 
               class="search-field" 
               autocomplete="off">
        <div class="suggestions-dropdown" id="suggestionsDropdown"></div>
    </div>

    <!-- Status Display -->
    <div id="status">Loading...</div>

    <!-- Map Section -->
    <div class="map">
        <div id="svg-container">
            <!-- SVG will be loaded here -->
        </div>
    </div>

    <!-- Button Section Below Map -->
    <div class="button-div">
        <div class="direction">
            <button id="openDirections"><img src="assets/dir.svg" alt="Directions"></button>
        </div>
        <div class="next-floor">
            <button class="previous"><img src="assets/backward.svg" alt="Previous Floor"></button>
            <button class="next"><img src="assets/forward.svg" alt="Next Floor"></button>
        </div>
    </div>

    <!-- Line Divider -->
    <div class="line"></div>

    <!-- Explore Section -->
    <div class="explore">
        <p class="heading">Explore the Campus</p>
        <div class="buttons">
            <div class="group-1">
                <button class="clas"><img src="assets/class.png" alt="Class"></button>
                <span class="label-1"><a href="">Class</a></span>
            </div>
            <div class="group-2">
                <button class="department"><img src="assets/department.png" alt="Department"></button>
                <span class="label-2"><a href="">Department</a></span>
            </div>
            <div class="group-3">
                <button class="faculties"><img src="assets/faculties.png" alt="Faculties"></button>
                <span class="label-3"><a href="">Faculties</a></span>
            </div>
        </div>
    </div>

    <!-- Directions Panel (Sliding from left) -->
    <div class="directions-panel" id="directionsPanel">
        <div class="back-button">
            <button class="back" onclick="closeDirections()">
                <img src="assets/back.svg" alt="Back" style="width: 24px; height: 24px;">
            </button>
        </div>
        <div class="inputs">
            <div class="input-container">
                <input type="text" 
                       id="fromInput" 
                       placeholder="Choose start location" 
                       class="input1">
                <div id="fromSuggestions" class="suggestions-dropdown"></div>
            </div>
            
            <div class="input-container">
                <input type="text" 
                       id="toInput" 
                       placeholder="Choose destination" 
                       class="input2">
                <div id="toSuggestions" class="suggestions-dropdown"></div>
            </div>
            
            <button class="find" id="findPathBtn">Find Path</button>
            <button class="clear" id="clearPathBtn">Clear Path</button>
        </div>
    </div>

    <script>
        // Global variables
        let campusNodes = [];
        let campusGraph = {};
        let currentPath = [];
        let startNode = null;
        let destinationNode = null;
        let selectedSuggestionIndex = -1;
        let panzoomInstance = null;
        let defaultViewState = null;
        let isZoomedIn = false; // Track zoom state for double-tap

        // Initialize the application
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('üöÄ Starting Campus Connect with cloned design...');
            try {
                setupNavigation();
                setupDirectionsPanel();
                setupSearch();
                setupExploreButtons();
                await loadApplication();
                console.log('üöÄ Application loaded successfully');
            } catch (error) {
                console.error('üöÄ Error in DOMContentLoaded:', error);
            }
        });

        // Setup navigation (floor links and mobile menu)
        function setupNavigation() {
            // Global floor state
            window.currentFloor = 'second'; // Default to second floor
            
            // Mobile menu toggle
            const menuToggle = document.getElementById('menuToggle');
            const sidebar = document.querySelector('.sidebar');

            if (menuToggle && sidebar) {
                menuToggle.addEventListener('click', (e) => {
                    e.stopPropagation();
                    sidebar.style.display = sidebar.style.display === 'flex' ? 'none' : 'flex';
                });

                // Close sidebar when clicking outside
                document.addEventListener('click', (e) => {
                    if (!sidebar.contains(e.target) && !menuToggle.contains(e.target)) {
                        sidebar.style.display = 'none';
                    }
                });
            }

            // Floor navigation links
            const floorLinks = document.querySelectorAll('[data-floor]');
            floorLinks.forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const floor = link.getAttribute('data-floor');
                    console.log(`Floor ${floor} selected`);
                    if (floor === '1') {
                        window.currentFloor = 'first';
                        loadApplication(); // Reload with first floor
                    } else if (floor === '2') {
                        window.currentFloor = 'second';
                        loadApplication(); // Reload with second floor
                    } else if (floor === '3') {
                        window.currentFloor = 'third';
                        loadApplication(); // Reload with third floor
                    } else {
                        showFloorMessage(`Floor ${floor}`, 'Floor navigation coming soon!');
                    }
                    if (sidebar) {
                        sidebar.style.display = 'none';
                    }
                });
            });

            // Directions button
            const openDirectionsBtn = document.getElementById('openDirections');
            if (openDirectionsBtn) {
                openDirectionsBtn.addEventListener('click', () => {
                    document.getElementById('directionsPanel').classList.add('open');
                });
            }

            // Floor navigation buttons
            const nextBtn = document.querySelector('.next');
            const prevBtn = document.querySelector('.previous');
            
            if (nextBtn) {
                nextBtn.addEventListener('click', () => {
                    if (window.currentFloor === 'first') {
                        window.currentFloor = 'second';
                        loadApplication();
                    } else if (window.currentFloor === 'second') {
                        window.currentFloor = 'third';
                        loadApplication();
                    } else {
                        showFloorMessage('Next Floor', 'Already at top floor');
                    }
                });
            }
            if (prevBtn) {
                prevBtn.addEventListener('click', () => {
                    if (window.currentFloor === 'third') {
                        window.currentFloor = 'second';
                        loadApplication();
                    } else if (window.currentFloor === 'second') {
                        window.currentFloor = 'first';
                        loadApplication();
                    } else {
                        showFloorMessage('Previous Floor', 'Already at bottom floor');
                    }
                });
            }
        }

        // Setup explore buttons
        function setupExploreButtons() {
            const classBtn = document.querySelector('.clas');
            const deptBtn = document.querySelector('.department');
            const facultiesBtn = document.querySelector('.faculties');

            if (classBtn) {
                classBtn.addEventListener('click', () => {
                    filterByCategory('classroom');
                    highlightClassroomAreas();
                });
            }
            
            if (deptBtn) {
                deptBtn.addEventListener('click', () => {
                    removeClassroomHighlights();
                    filterByCategory('department');
                });
            }
            
            if (facultiesBtn) {
                facultiesBtn.addEventListener('click', () => {
                    removeClassroomHighlights();
                    filterByCategory('staff');
                });
            }
        }

        // Function to highlight all classroom areas with FFD6D4 color
        function highlightClassroomAreas() {
            console.log('üè´ Highlighting classroom areas...');
            
            // Find the SVG container and the actual SVG element inside it
            const svgContainer = document.getElementById('svg-container');
            if (!svgContainer) {
                console.error('‚ùå SVG container not found');
                return;
            }

            const svgElement = svgContainer.querySelector('svg');
            if (!svgElement) {
                console.error('‚ùå SVG element not found inside container');
                return;
            }

            console.log('‚úÖ Found SVG container and element');

            // First, remove any existing classroom highlights
            removeClassroomHighlights();
            
            // Find all path elements with FFD6D4 fill or stroke
            const pathElements = svgElement.querySelectorAll('path[fill="#FFD6D4"], path[stroke="#FFD6D4"]');
            
            console.log(`üéØ Found ${pathElements.length} classroom area elements to highlight`);
            
            pathElements.forEach((element, index) => {
                // Add a highlighting class for easy removal later
                element.classList.add('classroom-highlight');
                
                // Create a pulsing highlight effect
                const originalFill = element.getAttribute('fill');
                const originalStroke = element.getAttribute('stroke');
                const originalStrokeWidth = element.getAttribute('stroke-width') || '1';
                
                // Apply highlight styling
                element.style.filter = 'drop-shadow(0 0 8px rgba(255, 214, 212, 0.8))';
                element.style.strokeWidth = (parseFloat(originalStrokeWidth) + 2).toString();
                element.style.stroke = '#FF6B6B';
                element.style.animation = 'classroom-pulse 2s ease-in-out infinite';
                
                console.log(`‚úÖ Highlighted classroom area element ${index + 1}`);
            });

            // Add CSS animation if it doesn't exist
            addClassroomHighlightCSS();
        }

        // Function to remove classroom area highlights
        function removeClassroomHighlights() {
            const highlightedElements = document.querySelectorAll('.classroom-highlight');
            highlightedElements.forEach(element => {
                element.classList.remove('classroom-highlight');
                element.style.filter = '';
                element.style.strokeWidth = '';
                element.style.stroke = '';
                element.style.animation = '';
            });
            console.log(`üßπ Removed highlights from ${highlightedElements.length} elements`);
        }

        // Function to add CSS for classroom highlighting animation
        function addClassroomHighlightCSS() {
            if (!document.getElementById('classroom-highlight-styles')) {
                const style = document.createElement('style');
                style.id = 'classroom-highlight-styles';
                style.textContent = `
                    @keyframes classroom-pulse {
                        0%, 100% { 
                            filter: drop-shadow(0 0 8px rgba(255, 214, 212, 0.8));
                            transform: scale(1);
                        }
                        50% { 
                            filter: drop-shadow(0 0 15px rgba(255, 107, 107, 1));
                            transform: scale(1.02);
                        }
                    }
                    .classroom-highlight {
                        transform-origin: center;
                        transition: all 0.3s ease;
                    }
                `;
                document.head.appendChild(style);
            }
        }

        function recenterMap() {
            if (panzoomInstance && defaultViewState) {
                console.log('üéØ Recentering map to your preferred default view...');
                panzoomInstance.zoom(defaultViewState.scale, { animate: true });
                panzoomInstance.pan(defaultViewState.x, defaultViewState.y, { animate: true });
                isZoomedIn = false; // Reset zoom state
            }
        }

        function setMaxZoomOut() {
            if (panzoomInstance) {
                console.log('üîç Setting to maximum zoom out level...');
                // Use the specific transform values you provided
                panzoomInstance.zoom(1.79482, { animate: true });
                panzoomInstance.pan(-22.302, -8.25484, { animate: true });
                isZoomedIn = false;
            }
        }

        function setupPanzoom(svg) {
            console.log('üéÆ Setting up panzoom controls...');
            
            const currentFloor = window.currentFloor || 'second';
            
            // Get the actual SVG viewBox dimensions based on current floor
            const dimensions = currentFloor === 'third' 
                ? { width: 4259, height: 2952 }
                : { width: 8830, height: 6238 };
            
            console.log(`üìê Using ${currentFloor} floor SVG dimensions:`, dimensions);
            
            // Get the container (viewport) dimensions
            const container = document.getElementById('svg-container');
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            
            console.log('üìê Container dimensions:', { width: containerWidth, height: containerHeight });
            
            // Calculate aspect ratios
            const svgAspectRatio = dimensions.width / dimensions.height;
            const containerAspectRatio = containerWidth / containerHeight;
            
            console.log('üìê Aspect ratios:', { svg: svgAspectRatio, container: containerAspectRatio });
            
            // Calculate the scale factor to fit the entire SVG within the container
            let scale;
            if (containerAspectRatio > svgAspectRatio) {
                scale = containerHeight / dimensions.height;
            } else {
                scale = containerWidth / dimensions.width;
            }
            
            // Apply padding by reducing scale
            scale *= 0.95;
            
            console.log('üìê Calculated base scale:', scale);
            
            // Store default view state with floor-specific values
            defaultViewState = currentFloor === 'third' 
                ? { scale: scale, x: 0, y: 0 }  // Centered for third floor
                : { scale: 1.79482, x: -22.302, y: -8.25484 };  // Your preferred second floor view
            
            console.log('üìê Default view state:', defaultViewState);
            
            // Initialize panzoom
            panzoomInstance = Panzoom(svg, {
                maxScale: currentFloor === 'third' ? Math.max(3, defaultViewState.scale * 4) : 3.61433,
                minScale: currentFloor === 'third' ? defaultViewState.scale * 0.5 : 1.79482,
                contain: 'outside',
                cursor: 'default',
                animate: true,
                duration: 300,
                easing: 'ease-in-out',
                startScale: defaultViewState.scale,
                startX: defaultViewState.x,
                startY: defaultViewState.y,
                disablePan: true,  // Disable default panning
                disableZoom: true  // Disable default zooming
            });
            
            // Remove default wheel zoom - only allow 2-finger gestures
            // container.addEventListener('wheel', panzoomInstance.zoomWithWheel);
            
            // Add custom 2-finger touch handling
            setupTwoFingerGestures(container, svg);
            
            // Listen for zoom changes
            svg.addEventListener('panzoomchange', (e) => {
                const currentScale = panzoomInstance.getScale();
                isZoomedIn = currentScale > (defaultViewState.scale * 1.2);
                console.log(`üìè Current scale: ${currentScale}, Zoomed in: ${isZoomedIn}`);
            });
            
            // Setup double-tap zoom
            setupDoubleTapZoom(svg);
            
            // Apply initial transform
            requestAnimationFrame(() => {
                console.log('üéØ Applying initial transform for', currentFloor, 'floor');
                panzoomInstance.zoom(defaultViewState.scale, { animate: false });
                panzoomInstance.pan(defaultViewState.x, defaultViewState.y, { animate: false });
                isZoomedIn = false;
                console.log('‚úÖ Initial transform applied');
            });
            
            console.log('‚úÖ Panzoom setup complete');
        }

        function setupTwoFingerGestures(container, svg) {
            let initialDistance = 0;
            let initialScale = 1;
            let initialCenter = { x: 0, y: 0 };
            let touches = [];

            container.addEventListener('touchstart', (e) => {
                touches = Array.from(e.touches);
                
                if (touches.length === 2) {
                    e.preventDefault();
                    
                    // Calculate initial distance between fingers
                    const touch1 = touches[0];
                    const touch2 = touches[1];
                    
                    initialDistance = Math.sqrt(
                        Math.pow(touch2.clientX - touch1.clientX, 2) + 
                        Math.pow(touch2.clientY - touch1.clientY, 2)
                    );
                    
                    // Calculate center point between fingers
                    initialCenter = {
                        x: (touch1.clientX + touch2.clientX) / 2,
                        y: (touch1.clientY + touch2.clientY) / 2
                    };
                    
                    // Get current scale
                    initialScale = panzoomInstance.getScale();
                    
                    console.log('ü§û Two-finger gesture started', { initialDistance, initialScale, initialCenter });
                }
            });

            container.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    
                    // Calculate current distance
                    const currentDistance = Math.sqrt(
                        Math.pow(touch2.clientX - touch1.clientX, 2) + 
                        Math.pow(touch2.clientY - touch1.clientY, 2)
                    );
                    
                    // Calculate current center
                    const currentCenter = {
                        x: (touch1.clientX + touch2.clientX) / 2,
                        y: (touch1.clientY + touch2.clientY) / 2
                    };
                    
                    // Calculate scale change
                    const scaleChange = currentDistance / initialDistance;
                    const newScale = Math.max(
                        panzoomInstance.getOptions().minScale,
                        Math.min(panzoomInstance.getOptions().maxScale, initialScale * scaleChange)
                    );
                    
                    // Calculate pan change
                    const panX = currentCenter.x - initialCenter.x;
                    const panY = currentCenter.y - initialCenter.y;
                    
                    // Apply zoom to focal point
                    const containerRect = container.getBoundingClientRect();
                    const focalX = currentCenter.x - containerRect.left;
                    const focalY = currentCenter.y - containerRect.top;
                    
                    panzoomInstance.zoomToPoint(newScale, { clientX: focalX, clientY: focalY }, { animate: false });
                }
            });

            container.addEventListener('touchend', (e) => {
                if (touches.length === 2) {
                    console.log('ü§û Two-finger gesture ended');
                }
                touches = Array.from(e.touches);
            });

            // Disable mouse wheel zoom completely
            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                console.log('üö´ Mouse wheel zoom disabled - use two fingers');
            });

            // Disable single-finger pan by overriding panzoom mouse events
            container.addEventListener('mousedown', (e) => {
                e.preventDefault();
                console.log('üö´ Single-finger/mouse pan disabled - use two fingers');
            });
        }

        function setupDoubleTapZoom(svg) {
            let lastTap = 0;
            
            svg.addEventListener('touchstart', (e) => {
                const currentTime = new Date().getTime();
                const tapLength = currentTime - lastTap;
                
                if (tapLength < 500 && tapLength > 0) {
                    // Double tap detected
                    e.preventDefault();
                    handleDoubleTap(e);
                }
                lastTap = currentTime;
            });

            // Also handle mouse double-click for desktop
            svg.addEventListener('dblclick', (e) => {
                e.preventDefault();
                handleDoubleTap(e);
            });
        }

        function handleDoubleTap(e) {
            console.log('üîç Double-tap detected, current zoom state:', isZoomedIn);
            
            if (!isZoomedIn) {
                // Calculate focal point from touch/click coordinates
                const containerRect = document.getElementById('svg-container').getBoundingClientRect();
                const focalX = (e.clientX || (e.touches && e.touches[0].clientX) || containerRect.left + containerRect.width / 2) - containerRect.left;
                const focalY = (e.clientY || (e.touches && e.touches[0].clientY) || containerRect.top + containerRect.height / 2) - containerRect.top;
                
                // Zoom to detail level (3x the default scale for room details)
                const targetScale = defaultViewState.scale * 3;
                
                console.log('üîç Zooming to detail level:', targetScale);
                console.log('üîç Focal point:', { x: focalX, y: focalY });
                
                panzoomInstance.zoom(targetScale, { 
                    animate: true,
                    focal: { x: focalX, y: focalY }
                });
                isZoomedIn = true;
            } else {
                // Reset to maximum zoom out level (your specified transform)
                console.log('üîç Resetting to maximum zoom out...');
                setMaxZoomOut();
                isZoomedIn = false;
            }
        }

        function showFloorMessage(title, message) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.9);
                color: white;
                padding: 20px 30px;
                border-radius: 10px;
                font-size: 18px;
                text-align: center;
                z-index: 10000;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                backdrop-filter: blur(10px);
            `;
            notification.innerHTML = `<strong>${title}</strong><br>${message}`;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                document.body.removeChild(notification);
            }, 3000);
        }

        // Directions panel setup
        function setupDirectionsPanel() {
            setupPanelInputs();
        }

        function closeDirections() {
            document.getElementById('directionsPanel').classList.remove('open');
        }

        // Enhanced Search with Dropdown Suggestions
        function setupSearch() {
            const searchField = document.getElementById('searchField');
            const dropdown = document.getElementById('suggestionsDropdown');

            searchField.addEventListener('input', handleSearchInput);
            searchField.addEventListener('keydown', handleSearchKeydown);
            searchField.addEventListener('focus', handleSearchFocus);
            searchField.addEventListener('click', handleSearchClick);
            
            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!searchField.contains(e.target) && !dropdown.contains(e.target)) {
                    dropdown.style.display = 'none';
                    selectedSuggestionIndex = -1;
                }
            });
        }

        function handleSearchInput(e) {
            const query = e.target.value.toLowerCase();
            const dropdown = document.getElementById('suggestionsDropdown');

            if (query.length === 0) {
                dropdown.style.display = 'none';
                return;
            }

            // Filter nodes based on search query
            const suggestions = campusNodes
                .filter(node => 
                    node.searchable && 
                    node.label && node.label.toLowerCase().includes(query)
                )
                .slice(0, 15); // Increased from 8 to 15 suggestions

            // If no results on current floor, search other floor
            if (suggestions.length === 0 && query.match(/^\d{3}$/)) {
                const currentFloor = window.currentFloor || 'second';
                const otherFloor = currentFloor === 'third' ? 'second' : 'third';
                
                // Show helpful message about floor switching
                dropdown.innerHTML = `
                    <div class="suggestion-item no-results" style="padding: 15px; color: #666; text-align: center; border-bottom: 1px solid #eee;">
                        <div style="margin-bottom: 8px;">
                            üîç No room "${query}" found on ${currentFloor} floor
                        </div>
                        <div style="font-size: 12px; color: #999;">
                            Try switching to ${otherFloor} floor or search for a different room
                        </div>
                    </div>
                `;
                dropdown.style.display = 'block';
                return;
            }

            displaySuggestions(suggestions, dropdown);
        }

        function handleSearchKeydown(e) {
            const dropdown = document.getElementById('suggestionsDropdown');
            const suggestions = dropdown.querySelectorAll('.suggestion-item');

            switch(e.key) {
                case 'ArrowDown':
                    e.preventDefault();
                    selectedSuggestionIndex = Math.min(selectedSuggestionIndex + 1, suggestions.length - 1);
                    updateSelectedSuggestion(suggestions);
                    break;
                
                case 'ArrowUp':
                    e.preventDefault();
                    selectedSuggestionIndex = Math.max(selectedSuggestionIndex - 1, -1);
                    updateSelectedSuggestion(suggestions);
                    break;
                
                case 'Enter':
                    e.preventDefault();
                    if (selectedSuggestionIndex >= 0 && suggestions[selectedSuggestionIndex]) {
                        selectSuggestion(suggestions[selectedSuggestionIndex].dataset.nodeId);
                    } else {
                        // Handle direct search when no suggestion is selected
                        const query = e.target.value.toLowerCase();
                        if (query.length > 0) {
                            const matchingNode = campusNodes.find(node => 
                                node.searchable && 
                                node.label && 
                                node.label.toLowerCase().includes(query)
                            );
                            if (matchingNode) {
                                selectSuggestion(matchingNode.id);
                            }
                        }
                    }
                    break;
                
                case 'Escape':
                    dropdown.style.display = 'none';
                    selectedSuggestionIndex = -1;
                    break;
            }
        }

        function handleSearchFocus(e) {
            if (e.target.value.trim()) {
                handleSearchInput(e);
            }
        }

        function handleSearchClick(e) {
            // Show all searchable nodes when search field is clicked
            const dropdown = document.getElementById('suggestionsDropdown');
            const allSuggestions = campusNodes
                .filter(node => node.searchable && node.label)
                .slice(0, 15); // Show top 15 suggestions

            displaySuggestions(allSuggestions, dropdown);
        }

        function displaySuggestions(suggestions, dropdown) {
            dropdown.innerHTML = '';

            if (suggestions.length === 0) {
                dropdown.style.display = 'none';
                return;
            }

            suggestions.forEach((node, index) => {
                const item = document.createElement('div');
                item.className = 'suggestion-item';
                item.dataset.nodeId = node.id;
                
                item.innerHTML = `
                    <div class="suggestion-icon">${getNodeIcon(node.type)}</div>
                    <div class="suggestion-text">
                        <div>${node.label}</div>
                        <div class="suggestion-category">${node.type}</div>
                    </div>
                `;

                item.addEventListener('click', () => selectSuggestion(node.id));
                dropdown.appendChild(item);
            });

            dropdown.style.display = 'block';
            selectedSuggestionIndex = -1;
        }

        function updateSelectedSuggestion(suggestions) {
            suggestions.forEach((item, index) => {
                item.classList.toggle('selected', index === selectedSuggestionIndex);
            });
        }

        function selectSuggestion(nodeId) {
            console.log('üîç selectSuggestion called with nodeId:', nodeId);
            const node = campusNodes.find(n => n.id === nodeId);
            console.log('üîç Found node:', node);
            
            if (!node) {
                console.error('‚ùå Node not found:', nodeId);
                return;
            }

            // Set search field value and close dropdown
            document.getElementById('searchField').value = node.label;
            document.getElementById('suggestionsDropdown').style.display = 'none';
            
            // Zoom to the selected node for better visibility
            console.log('üîç Zooming to node...');
            zoomToNode(nodeId);
            
            // Highlight corresponding zone and show info box (main feature)
            console.log('üîç Highlighting zone and showing info box...');
            highlightCorrespondingZone(node);
            showInfoBoxForNode(node);
        }

        function getNodeIcon(nodeType) {
            const icons = {
                'class': 'üè´',
                'stairway': 'üîº',
                'intersection': 'üîÄ',
                'invisible': 'üìç',
                'data_node': 'üìå'
            };
            return icons[nodeType] || 'üìç';
        }

        function highlightCorrespondingZone(node) {
            // Find zone that contains this node
            if (window.zoneData && window.zoneData.length > 0) {
                const correspondingZone = window.zoneData.find(zone => {
                    // Check if node coordinates are inside zone polygon using points array
                    return isPointInPolygonPoints(node.x, node.y, zone.points);
                });

                if (correspondingZone) {
                    const zoneElement = document.querySelector(`[data-zone-id="${correspondingZone.id}"]`);
                    if (zoneElement) {
                        // Clear any existing animations
                        zoneElement.style.animation = 'none';
                        
                        // Store original styling
                        const originalFill = zoneElement.getAttribute('fill');
                        const originalFillOpacity = zoneElement.getAttribute('fill-opacity');
                        const originalStrokeOpacity = zoneElement.getAttribute('stroke-opacity');
                        
                        // Apply highlight styling
                        zoneElement.setAttribute('fill', '#ffcc00');
                        zoneElement.style.animation = 'zoneHighlightPulse 1.5s ease-in-out 3';
                        
                        // Reset after animation
                        setTimeout(() => {
                            zoneElement.setAttribute('fill', originalFill || 'rgba(0, 123, 255, 0.3)');
                            zoneElement.setAttribute('fill-opacity', originalFillOpacity || '0.3');
                            zoneElement.setAttribute('stroke-opacity', originalStrokeOpacity || '0.6');
                            zoneElement.style.animation = '';
                        }, 4500); // 1.5s * 3 repetitions
                    }
                }
            }
        }

        function isPointInPolygon(x, y, coordinates) {
            let inside = false;
            const coords = coordinates.split(' ').map(coord => {
                const [cx, cy] = coord.split(',').map(Number);
                return { x: cx, y: cy };
            });

            for (let i = 0, j = coords.length - 1; i < coords.length; j = i++) {
                if (((coords[i].y > y) !== (coords[j].y > y)) &&
                    (x < (coords[j].x - coords[i].x) * (y - coords[i].y) / (coords[j].y - coords[i].y) + coords[i].x)) {
                    inside = !inside;
                }
            }
            return inside;
        }

        // New function to handle points array format from zone data
        function isPointInPolygonPoints(x, y, points) {
            let inside = false;
            for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
                const xi = points[i][0], yi = points[i][1];
                const xj = points[j][0], yj = points[j][1];
                
                if (((yi > y) !== (yj > y)) &&
                    (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                    inside = !inside;
                }
            }
            return inside;
        }

        function showInfoBoxForNode(node) {
            console.log('üîç showInfoBoxForNode called with node:', node);
            console.log('üîç Zone data available:', !!window.zoneData, window.zoneData?.length);
            
            // Find the zone that contains this node
            if (window.zoneData && window.zoneData.length > 0) {
                const correspondingZone = window.zoneData.find(zone => {
                    const result = isPointInPolygonPoints(node.x, node.y, zone.points);
                    console.log(`üîç Checking zone ${zone.id}: point in polygon = ${result}`);
                    return result;
                });

                console.log('üîç Found corresponding zone:', correspondingZone);

                if (correspondingZone) {
                    // Show info box near the highlighted zone
                    const infoBox = document.getElementById('zone-info-box');
                    console.log('üîç Info box element:', !!infoBox);
                    
                    if (infoBox) {
                        let displayName = correspondingZone.id.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                        console.log('üîç Setting info box content...');
                        
                        infoBox.innerHTML = `
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                                <h3 style="margin: 0; color: #333; font-size: 18px;">${node.label}</h3>
                                <button id="close-info-btn" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #666;">√ó</button>
                            </div>
                            <div style="margin-bottom: 16px;">
                                <p style="margin: 4px 0; color: #666; font-size: 14px;">
                                    <span style="font-weight: 500;">Location:</span> ${displayName}
                                </p>
                                <p style="margin: 4px 0; color: #666; font-size: 14px;">
                                    <span style="font-weight: 500;">Category:</span> ${correspondingZone.category}
                                </p>
                                <p style="margin: 4px 0; color: #666; font-size: 14px;">
                                    <span style="font-weight: 500;">Type:</span> ${node.type || 'Location'}
                                </p>
                            </div>
                            <div style="display: flex; gap: 8px; flex-direction: column;">
                                <button id="navigate-to-btn" style="width: 100%; padding: 12px; background: #28a745; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 500; transition: background-color 0.2s;">
                                    üìç Navigate Here
                                </button>
                                <button id="set-destination-btn" style="width: 100%; padding: 12px; background: #007BFF; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 500; transition: background-color 0.2s;">
                                    üéØ Set as Destination
                                </button>
                                <button id="set-start-btn" style="width: 100%; padding: 12px; background: #17a2b8; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 500; transition: background-color 0.2s;">
                                    üöÄ Set as Start Point
                                </button>
                            </div>
                        `;
                        
                        // Position the info box near the center-right of the screen for better visibility
                        infoBox.style.left = '60%';
                        infoBox.style.top = '30%';
                        infoBox.style.transform = 'translate(-50%, -50%)';
                        infoBox.style.display = 'block';
                        infoBox.style.zIndex = '1002';
                        
                        console.log('üîç Info box displayed, adding event listeners...');
                        
                        // Add event listeners
                        document.getElementById('close-info-btn').addEventListener('click', () => {
                            console.log('üîç Close button clicked');
                            infoBox.style.display = 'none';
                        });
                        
                        document.getElementById('navigate-to-btn').addEventListener('click', () => {
                            console.log('üîç Navigate button clicked');
                            openDirectionsPanel();
                            setDestinationNode(node.id);
                            infoBox.style.display = 'none';
                        });
                        
                        document.getElementById('set-destination-btn').addEventListener('click', () => {
                            console.log('üîç Set destination button clicked');
                            setDestinationNode(node.id);
                            
                            // Open the directions panel and populate the destination field
                            openDirectionsPanel();
                            setTimeout(() => {
                                const toInput = document.getElementById('toInput');
                                if (toInput) {
                                    toInput.value = node.label;
                                }
                            }, 100);
                            
                            document.getElementById('status').textContent = `Destination set: ${node.label}`;
                            infoBox.style.display = 'none';
                        });
                        
                        document.getElementById('set-start-btn').addEventListener('click', () => {
                            console.log('üîç Set start button clicked');
                            setStartNode(node.id);
                            
                            // Open the directions panel and populate the start field
                            openDirectionsPanel();
                            setTimeout(() => {
                                const fromInput = document.getElementById('fromInput');
                                if (fromInput) {
                                    fromInput.value = node.label;
                                }
                                // Focus on destination field since start is already set
                                const toInput = document.getElementById('toInput');
                                if (toInput) {
                                    toInput.focus();
                                }
                            }, 100);
                            
                            document.getElementById('status').textContent = `Start point set: ${node.label}`;
                            infoBox.style.display = 'none';
                        });
                    }
                } else {
                    console.log('üîç No zone found, showing simple info box...');
                    // If no zone found, show a simpler info box
                    const infoBox = document.getElementById('zone-info-box');
                    if (infoBox) {
                        infoBox.innerHTML = `
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                                <h3 style="margin: 0; color: #333; font-size: 18px;">${node.label}</h3>
                                <button id="close-info-btn" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #666;">√ó</button>
                            </div>
                            <div style="margin-bottom: 16px;">
                                <p style="margin: 4px 0; color: #666; font-size: 14px;">
                                    <span style="font-weight: 500;">Type:</span> ${node.type || 'Location'}
                                </p>
                                <p style="margin: 4px 0; color: #999; font-size: 12px; font-style: italic;">
                                    Zone information not available
                                </p>
                            </div>
                            <div style="display: flex; gap: 8px; flex-direction: column;">
                                <button id="navigate-to-btn" style="width: 100%; padding: 12px; background: #28a745; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 500;">
                                    üìç Navigate Here
                                </button>
                                <button id="set-destination-btn" style="width: 100%; padding: 12px; background: #007BFF; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 500;">
                                    üéØ Set as Destination
                                </button>
                                <button id="set-start-btn" style="width: 100%; padding: 12px; background: #17a2b8; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 500;">
                                    üöÄ Set as Start Point
                                </button>
                            </div>
                        `;
                        
                        // Position and show the info box
                        infoBox.style.left = '60%';
                        infoBox.style.top = '30%';
                        infoBox.style.transform = 'translate(-50%, -50%)';
                        infoBox.style.display = 'block';
                        infoBox.style.zIndex = '1002';
                        
                        console.log('üîç Simple info box displayed, adding event listeners...');
                        
                        // Add event listeners
                        document.getElementById('close-info-btn').addEventListener('click', () => {
                            infoBox.style.display = 'none';
                        });
                        
                        document.getElementById('navigate-to-btn').addEventListener('click', () => {
                            openDirectionsPanel();
                            setDestinationNode(node.id);
                            infoBox.style.display = 'none';
                        });
                        
                        document.getElementById('set-destination-btn').addEventListener('click', () => {
                            setDestinationNode(node.id);
                            
                            // Open the directions panel and populate the destination field
                            openDirectionsPanel();
                            setTimeout(() => {
                                const toInput = document.getElementById('toInput');
                                if (toInput) {
                                    toInput.value = node.label;
                                }
                            }, 100);
                            
                            document.getElementById('status').textContent = `Destination set: ${node.label}`;
                            infoBox.style.display = 'none';
                        });
                        
                        document.getElementById('set-start-btn').addEventListener('click', () => {
                            setStartNode(node.id);
                            
                            // Open the directions panel and populate the start field
                            openDirectionsPanel();
                            setTimeout(() => {
                                const fromInput = document.getElementById('fromInput');
                                if (fromInput) {
                                    fromInput.value = node.label;
                                }
                                // Focus on destination field since start is already set
                                const toInput = document.getElementById('toInput');
                                if (toInput) {
                                    toInput.focus();
                                }
                            }, 100);
                            
                            document.getElementById('status').textContent = `Start point set: ${node.label}`;
                            infoBox.style.display = 'none';
                        });
                    }
                }
            } else {
                console.log('üîç Zone data not available, showing basic info box...');
                // Show basic info box even without zone data
                const infoBox = document.getElementById('zone-info-box');
                if (infoBox) {
                    infoBox.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                            <h3 style="margin: 0; color: #333; font-size: 18px;">${node.label}</h3>
                            <button id="close-info-btn" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #666;">√ó</button>
                        </div>
                        <div style="margin-bottom: 16px;">
                            <p style="margin: 4px 0; color: #666; font-size: 14px;">
                                <span style="font-weight: 500;">Type:</span> ${node.type || 'Location'}
                            </p>
                        </div>
                        <div style="display: flex; gap: 8px; flex-direction: column;">
                            <button id="navigate-to-btn" style="width: 100%; padding: 12px; background: #28a745; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 500;">
                                üìç Navigate Here
                            </button>
                            <button id="set-destination-btn" style="width: 100%; padding: 12px; background: #007BFF; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 500;">
                                üéØ Set as Destination
                            </button>
                            <button id="set-start-btn" style="width: 100%; padding: 12px; background: #17a2b8; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 500;">
                                üöÄ Set as Start Point
                            </button>
                        </div>
                    `;
                    
                    infoBox.style.left = '60%';
                    infoBox.style.top = '30%';
                    infoBox.style.transform = 'translate(-50%, -50%)';
                    infoBox.style.display = 'block';
                    infoBox.style.zIndex = '1002';
                    
                    console.log('üîç Basic info box displayed');
                    
                    // Add event listeners
                    document.getElementById('close-info-btn').addEventListener('click', () => {
                        infoBox.style.display = 'none';
                    });
                    
                    document.getElementById('navigate-to-btn').addEventListener('click', () => {
                        openDirectionsPanel();
                        setDestinationNode(node.id);
                        infoBox.style.display = 'none';
                    });
                    
                    document.getElementById('set-destination-btn').addEventListener('click', () => {
                        setDestinationNode(node.id);
                        
                        // Open the directions panel and populate the destination field
                        openDirectionsPanel();
                        setTimeout(() => {
                            const toInput = document.getElementById('toInput');
                            if (toInput) {
                                toInput.value = node.label;
                            }
                        }, 100);
                        
                        document.getElementById('status').textContent = `Destination set: ${node.label}`;
                        infoBox.style.display = 'none';
                    });
                    
                    document.getElementById('set-start-btn').addEventListener('click', () => {
                        setStartNode(node.id);
                        
                        // Open the directions panel and populate the start field
                        openDirectionsPanel();
                        setTimeout(() => {
                            const fromInput = document.getElementById('fromInput');
                            if (fromInput) {
                                fromInput.value = node.label;
                            }
                            // Focus on destination field since start is already set
                            const toInput = document.getElementById('toInput');
                            if (toInput) {
                                toInput.focus();
                            }
                        }, 100);
                        
                        document.getElementById('status').textContent = `Start point set: ${node.label}`;
                        infoBox.style.display = 'none';
                    });
                }
            }
        }

        function openDirectionsPanel() {
            const panel = document.getElementById('directionsPanel');
            panel.classList.add('open');
            
            // Focus on the from input for user to enter start location
            setTimeout(() => {
                document.getElementById('fromInput').focus();
            }, 300);
        }

        // Panel inputs setup with same search functionality
        function setupPanelInputs() {
            console.log('üîß Setting up panel inputs...');
            const fromInput = document.getElementById('fromInput');
            const toInput = document.getElementById('toInput');
            const findBtn = document.getElementById('findPathBtn');
            const clearBtn = document.getElementById('clearPathBtn');

            console.log('üîß Panel elements found:', {
                fromInput: !!fromInput,
                toInput: !!toInput,
                findBtn: !!findBtn,
                clearBtn: !!clearBtn
            });

            if (!fromInput || !toInput) {
                console.error('‚ùå Panel input elements not found!');
                return;
            }

            // Setup search for both inputs
            setupPanelSearch(fromInput, 'fromSuggestions', 'from');
            setupPanelSearch(toInput, 'toSuggestions', 'to');

            findBtn.addEventListener('click', findPathFromPanel);
            clearBtn.addEventListener('click', clearPath);
            
            console.log('‚úÖ Panel inputs setup complete');
        }

        function setupPanelSearch(input, dropdownId, type) {
            console.log(`üîß Setting up panel search for ${type}, dropdown: ${dropdownId}`);
            const dropdown = document.getElementById(dropdownId);
            
            if (!dropdown) {
                console.error(`‚ùå Dropdown element not found: ${dropdownId}`);
                return;
            }
            
            console.log(`‚úÖ Dropdown found for ${type}:`, dropdown);

            input.addEventListener('input', (e) => {
                console.log(`üìù Input event on ${type}: "${e.target.value}"`);
                handlePanelSearchInput(e, dropdown, type);
            });

            input.addEventListener('keydown', (e) => {
                handlePanelSearchKeydown(e, dropdown, type);
            });

            // Add focus handling like main search
            input.addEventListener('focus', (e) => {
                console.log(`üîç Focus event on ${type}`);
                if (e.target.value.trim()) {
                    handlePanelSearchInput(e, dropdown, type);
                }
            });

            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!input.contains(e.target) && !dropdown.contains(e.target)) {
                    dropdown.style.display = 'none';
                    selectedSuggestionIndex = -1;
                }
            });
            
            console.log(`‚úÖ Panel search setup complete for ${type}`);
        }

        function handlePanelSearchInput(e, dropdown, type) {
            const query = e.target.value.toLowerCase();
            
            console.log(`üîç Panel search (${type}): "${query}"`);
            console.log(`üîç Available campus nodes: ${campusNodes.length}`);

            if (query.length === 0) {
                dropdown.style.display = 'none';
                return;
            }

            // Filter nodes based on search query - same as main search
            const suggestions = campusNodes
                .filter(node => {
                    const isSearchable = node.searchable;
                    const hasLabel = node.label && node.label.toLowerCase().includes(query);
                    if (isSearchable && hasLabel) {
                        console.log(`‚úÖ Found match: ${node.label}`);
                    }
                    return isSearchable && hasLabel;
                })
                .slice(0, 15); // Same limit as main search

            console.log(`üîç Panel suggestions found: ${suggestions.length}`);
            
            // If no results on current floor, show helpful message
            if (suggestions.length === 0 && query.match(/^\d{3}$/)) {
                const currentFloor = window.currentFloor || 'second';
                const otherFloor = currentFloor === 'third' ? 'second' : 'third';
                
                dropdown.innerHTML = `
                    <div class="suggestion-item no-results" style="padding: 15px; color: #666; text-align: center; border-bottom: 1px solid #eee;">
                        <div style="margin-bottom: 8px;">
                            üîç No room "${query}" found on ${currentFloor} floor
                        </div>
                        <div style="font-size: 12px; color: #999;">
                            Try switching to ${otherFloor} floor
                        </div>
                    </div>
                `;
                dropdown.style.display = 'block';
                return;
            }
            
            displayPanelSuggestions(suggestions, dropdown, type);
        }

        function handlePanelSearchKeydown(e, dropdown, type) {
            const suggestions = dropdown.querySelectorAll('.suggestion-item');

            switch(e.key) {
                case 'ArrowDown':
                    e.preventDefault();
                    selectedSuggestionIndex = Math.min(selectedSuggestionIndex + 1, suggestions.length - 1);
                    updatePanelSelectedSuggestion(suggestions);
                    break;
                
                case 'ArrowUp':
                    e.preventDefault();
                    selectedSuggestionIndex = Math.max(selectedSuggestionIndex - 1, -1);
                    updatePanelSelectedSuggestion(suggestions);
                    break;
                
                case 'Enter':
                    e.preventDefault();
                    if (selectedSuggestionIndex >= 0 && suggestions[selectedSuggestionIndex]) {
                        selectPanelSuggestion(suggestions[selectedSuggestionIndex].dataset.nodeId, type);
                    }
                    break;
                
                case 'Escape':
                    dropdown.style.display = 'none';
                    selectedSuggestionIndex = -1;
                    break;
            }
        }

        function updatePanelSelectedSuggestion(suggestions) {
            suggestions.forEach((item, index) => {
                item.classList.toggle('selected', index === selectedSuggestionIndex);
            });
        }

        function displayPanelSuggestions(suggestions, dropdown, type) {
            console.log(`üé® Displaying ${suggestions.length} panel suggestions for ${type}`);
            console.log(`üé® Dropdown element:`, dropdown);
            
            dropdown.innerHTML = '';

            if (suggestions.length === 0) {
                dropdown.style.display = 'none';
                console.log('‚ùå No suggestions to display');
                return;
            }

            suggestions.forEach((node) => {
                const item = document.createElement('div');
                item.className = 'suggestion-item';
                item.dataset.nodeId = node.id;
                
                item.innerHTML = `
                    <div class="suggestion-icon">${getNodeIcon(node.type)}</div>
                    <div class="suggestion-text">
                        <div>${node.label}</div>
                        <div class="suggestion-category">${node.type}</div>
                    </div>
                `;

                item.addEventListener('click', () => {
                    console.log(`üñ±Ô∏è Panel suggestion clicked: ${node.label} (${type})`);
                    selectPanelSuggestion(node.id, type);
                });
                dropdown.appendChild(item);
            });

            dropdown.style.display = 'block';
            selectedSuggestionIndex = -1;
            console.log('‚úÖ Panel suggestions displayed');
        }

        function selectPanelSuggestion(nodeId, type) {
            const node = campusNodes.find(n => n.id === nodeId);
            if (!node) return;

            if (type === 'from') {
                document.getElementById('fromInput').value = node.label;
                document.getElementById('fromSuggestions').style.display = 'none';
                startNode = nodeId;
                
                // Add visual feedback like main search
                zoomToNode(nodeId);
                highlightCorrespondingZone(node);
            } else {
                document.getElementById('toInput').value = node.label;
                document.getElementById('toSuggestions').style.display = 'none';
                destinationNode = nodeId;
                
                // Add visual feedback like main search
                zoomToNode(nodeId);
                highlightCorrespondingZone(node);
            }
        }

        function findPathFromPanel() {
            console.log('üîç Finding path from panel...');
            console.log('Start:', startNode, 'Destination:', destinationNode);
            console.log('Campus nodes available:', campusNodes?.length || 0);
            console.log('Campus graph available:', Object.keys(campusGraph || {}).length);
            
            if (!startNode || !destinationNode) {
                console.error('‚ùå Missing nodes:', { startNode, destinationNode });
                alert('Please select both start location and destination');
                return;
            }

            if (startNode === destinationNode) {
                alert('Start and destination cannot be the same');
                return;
            }

            // Debug: Check if nodes exist in data
            const startNodeData = campusNodes.find(n => n.id === startNode);
            const endNodeData = campusNodes.find(n => n.id === destinationNode);
            
            console.log('Start node data:', startNodeData);
            console.log('End node data:', endNodeData);
            console.log('Start in graph:', startNode in campusGraph);
            console.log('End in graph:', destinationNode in campusGraph);

            console.log('üìä Graph nodes available:', Object.keys(campusGraph).length);
            console.log('üéØ Campus nodes available:', campusNodes.length);

            const path = astarPath(campusGraph, campusNodes, startNode, destinationNode);
            
            if (path && path.length > 0) {
                console.log('‚úÖ Path found:', path);
                drawPath(path);
                currentPath = path;
                
                const status = document.getElementById('status');
                status.textContent = `Route: ${startNodeData?.label || startNode} ‚Üí ${endNodeData?.label || destinationNode} (${path.length - 1} steps)`;
                
                // Close the directions panel
                closeDirections();
                
                console.log('üéâ Pathfinding completed successfully');
            } else {
                console.error('‚ùå No path found');
                console.log('üîç Debugging info:', {
                    startExists: campusNodes.find(n => n.id === startNode),
                    endExists: campusNodes.find(n => n.id === destinationNode),
                    startInGraph: startNode in campusGraph,
                    endInGraph: destinationNode in campusGraph,
                    startConnections: campusGraph[startNode] ? Object.keys(campusGraph[startNode]).length : 0,
                    endConnections: campusGraph[destinationNode] ? Object.keys(campusGraph[destinationNode]).length : 0,
                    graphSize: Object.keys(campusGraph).length,
                    nodesSize: campusNodes.length
                });
                
                // Additional debugging for Room 309 and 314
                if (startNode === 'class_309' || destinationNode === 'class_309' || 
                    startNode === 'class_314' || destinationNode === 'class_314') {
                    console.log('üîç Room 309/314 specific debug:');
                    console.log('Room 309 connections:', campusGraph['class_309']);
                    console.log('Room 314 connections:', campusGraph['class_314']);
                }
                
                alert('No path found between selected locations. Check console for details.');
            }
        }

        function setDestinationNode(nodeId) {
            destinationNode = nodeId;
            const node = campusNodes.find(n => n.id === nodeId);
            const status = document.getElementById('status');
            status.textContent = `Destination set: ${node?.label || nodeId}. Tap to select start location.`;
        }

        function setStartNode(nodeId) {
            startNode = nodeId;
            const node = campusNodes.find(n => n.id === nodeId);
            const status = document.getElementById('status');
            status.textContent = `Start point set: ${node?.label || nodeId}. Tap to select destination.`;
        }

        function zoomToNode(nodeId) {
            const node = campusNodes.find(n => n.id === nodeId);
            if (!node) return;

            // Highlight the node
            highlightNode(nodeId, '#FF6B35');
            
            // Simple visual feedback - we'll implement proper zooming later if needed
            setTimeout(() => {
                const nodeElement = document.querySelector(`[data-id="${nodeId}"]`);
                if (nodeElement) {
                    nodeElement.style.stroke = '#FF6B35';
                    nodeElement.style.strokeWidth = '6';
                    
                    setTimeout(() => {
                        nodeElement.style.stroke = '#ffffff';
                        nodeElement.style.strokeWidth = '3';
                    }, 2000);
                }
            }, 100);
        }

        function filterByCategory(category) {
            const categoryMapping = {
                'classroom': ['class'],
                'department': ['class', 'stairway'],
                'staff': ['stairway']
            };

            const nodeTypes = categoryMapping[category] || [];
            const filteredNodes = campusNodes.filter(node => 
                node.searchable && nodeTypes.includes(node.type)
            );

            // Update search field to show first result
            if (filteredNodes.length > 0) {
                document.getElementById('searchField').value = '';
                displaySuggestions(filteredNodes, document.getElementById('suggestionsDropdown'));
            }
        }

        // Application loading (keeping all existing functionality)
        async function loadApplication() {
            console.log('üìÇ === STARTING LOAD APPLICATION ===');
            
            const loading = document.getElementById('loading');
            const container = document.getElementById('svg-container');
            const status = document.getElementById('status');

            try {
                // Step 1: Load SVG based on current floor
                console.log('üìÇ Loading SVG...');
                status.textContent = 'Loading map...';
                
                // Determine which floor to load
                const currentFloor = window.currentFloor || 'second';
                let svgPath, zonesPath, nodesPath;
                if (currentFloor === 'first') {
                    svgPath = 'floors/first-floor.svg';
                    zonesPath = './data/first_floor_zones.json';
                    nodesPath = './data/first_floor_nodes.json';
                } else if (currentFloor === 'second') {
                    svgPath = 'floors/second-floor.svg';
                    zonesPath = './data/second_floor_zones.json';
                    nodesPath = './data/second_floor_nodes.json';
                } else if (currentFloor === 'third') {
                    svgPath = 'floors/third-floor.svg';
                    zonesPath = './data/third_floor_zones.json';
                    nodesPath = './data/third_floor_nodes.json';
                }
                console.log(`üìÇ Loading ${currentFloor} floor:`);
                console.log(`  SVG: ${svgPath}`);
                console.log(`  Zones: ${zonesPath}`);
                console.log(`  Nodes: ${nodesPath}`);
                
                const svgResponse = await fetch(svgPath);
                console.log('üìÇ SVG Response:', svgResponse.ok, svgResponse.status, svgResponse.url);
                
                if (!svgResponse.ok) {
                    console.error(`‚ùå SVG fetch failed: ${svgResponse.status} for ${svgPath}`);
                    throw new Error(`SVG fetch failed: ${svgResponse.status}`);
                }
                
                const svgContent = await svgResponse.text();
                console.log('‚úÖ SVG loaded successfully, length:', svgContent.length);
                console.log('üìê SVG viewBox check:', svgContent.substring(0, 200));

                // Step 2: Load graph data
                status.textContent = 'Loading navigation data...';
                const cacheBuster = new Date().getTime();
                const graphResponse = await fetch(`${nodesPath}?v=${cacheBuster}`);
                if (!graphResponse.ok) {
                    throw new Error(`Graph fetch failed: ${graphResponse.status}`);
                }
                const originalGraphData = await graphResponse.json();

                // Step 3: Transform coordinates
                status.textContent = 'Processing data...';
                let transformedGraphData;
                if (currentFloor === 'first') {
                    // For first floor, use coordinates as-is (no rotation needed)
                    transformedGraphData = {
                        nodes: originalGraphData.nodes || [],
                        graph: originalGraphData.graph || originalGraphData.edges || {}
                    };
                } else {
                    transformedGraphData = transformCoordinatesForRotatedSVG(originalGraphData);
                }

                // Step 4: Setup interface
                container.innerHTML = svgContent;
                const svg = container.querySelector('svg');
                if (svg) {
                    svg.setAttribute('class', 'map-svg');
                    setupPanzoom(svg);
                    await addInteractiveZonesForFloor(svg, zonesPath);
                }

                // Store data
                campusNodes = transformedGraphData.nodes || [];
                campusGraph = transformedGraphData.graph || {};

                // Create nodes and setup
                createNodes();

                status.textContent = 'Ready - Search or explore the campus!';
                loading.style.display = 'none';

            } catch (error) {
                console.error('‚ùå Error loading application:', error);
                console.error('‚ùå Current floor:', window.currentFloor);
                console.error('‚ùå SVG Path attempted:', svgPath);
                console.error('‚ùå Error stack:', error.stack);
                status.textContent = 'Error loading map';
                loading.innerHTML = `
                    <div style="text-align: center; color: #e74c3c;">
                        <h3>Loading Error</h3>
                        <p>Failed to load campus map: ${error.message}</p>
                        <p>Floor: ${window.currentFloor || 'second'}</p>
                        <button onclick="location.reload()" style="padding: 10px 20px; background: #007BFF; color: white; border: none; border-radius: 5px; cursor: pointer;">
                            Retry
                        </button>
                    </div>
                `;
            }
        }

        // Keep all existing functions from your current implementation
        function transformCoordinatesForRotatedSVG(originalData) {
            console.log('üîÑ Starting coordinate transformation...');
            const currentFloor = window.currentFloor || 'second';
            
            // For third floor, coordinates are already rotated in the JSON file
            if (currentFloor === 'third') {
                console.log('‚úÖ Third floor detected - using coordinates as-is (already rotated in JSON)');
                return {
                    nodes: originalData.nodes || [],
                    graph: originalData.graph || originalData.edges || {}
                };
            }
            
            // Use appropriate dimensions for second floor
            const dimensions = { width: 8830, height: 6238 };
            
            console.log(`üîÑ Using ${currentFloor} floor dimensions: ${dimensions.width}x${dimensions.height}`);

            const transformedData = {
                nodes: [],
                graph: {}
            };

            if (originalData.nodes) {
                transformedData.nodes = originalData.nodes.map(node => {
                    return {
                        ...node,
                        x: dimensions.width - node.x,
                        y: dimensions.height - node.y
                    };
                });
            }

            if (originalData.graph) {
                transformedData.graph = { ...originalData.graph };
            }

            console.log(`‚úÖ Coordinate transformation completed for ${currentFloor} floor`);
            return transformedData;
        }

        function createNodes() {
            let overlay = document.getElementById('overlay');
            
            // If overlay doesn't exist, create it
            if (!overlay) {
                const svg = document.querySelector('#svg-container svg');
                if (svg) {
                    overlay = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    overlay.id = 'overlay';
                    svg.appendChild(overlay);
                } else {
                    console.error('‚ùå SVG element not found');
                    return;
                }
            }

            overlay.innerHTML = '';

            const pathLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            pathLayer.id = 'path-layer';
            overlay.appendChild(pathLayer);

            const nodesLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            nodesLayer.id = 'nodes-layer';
            overlay.appendChild(nodesLayer);

            console.log(`üîµ Creating ${campusNodes.length} nodes...`);

            campusNodes.forEach(node => {
                // Set searchable property for all nodes except invisible ones
                if (!node.hasOwnProperty('searchable')) {
                    node.searchable = node.type !== 'invisible' && node.label && node.label.trim() !== '';
                }

                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', node.x);
                circle.setAttribute('cy', node.y);
                circle.setAttribute('r', getNodeRadius(node));
                circle.setAttribute('fill', getNodeColor(node));
                circle.setAttribute('stroke', '#ffffff');
                circle.setAttribute('stroke-width', '3');
                circle.setAttribute('class', 'node');
                circle.setAttribute('data-id', node.id);
                circle.setAttribute('data-label', node.label);

                if (node.type === 'data_node') {
                    circle.setAttribute('class', 'node data-node');
                    circle.style.opacity = '0.6';
                }

                circle.addEventListener('click', () => selectNode(node));
                circle.addEventListener('mouseenter', function(e) {
                    showNodeLabel(node, e);
                });
                circle.addEventListener('mouseleave', function() {
                    hideNodeLabel();
                });
                circle.addEventListener('mousemove', function(e) {
                    updateLabelPosition(e);
                });

                nodesLayer.appendChild(circle);
            });

            console.log('‚úÖ Nodes created successfully');
        }

        function getNodeRadius(node) {
            switch (node.type) {
                case 'intersection': return 25;
                case 'class': return 18;
                case 'stairway': return 20;
                case 'invisible': return 12;
                default: return 14;
            }
        }

        function getNodeColor(node) {
            switch (node.type) {
                case 'class': return '#DC2626';
                case 'intersection': return '#7C3AED';
                case 'invisible': return '#10B981';
                case 'stairway': return '#F59E0B';
                case 'data_node': return '#9C27B0';
                case 'red_curve_location': return '#EF4444';
                default: return '#007BFF';
            }
        }

        function selectNode(node) {
            if (!startNode) {
                startNode = node.id;
                const status = document.getElementById('status');
                status.textContent = `Start: ${node.label}. Select destination or search above.`;
                highlightNode(node.id, '#00ff00', true);
            } else if (!destinationNode) {
                destinationNode = node.id;
                findPath();
            } else {
                // Reset and start new
                clearPath();
                startNode = node.id;
                destinationNode = null;
                const status = document.getElementById('status');
                status.textContent = `Start: ${node.label}. Select destination.`;
                highlightNode(node.id, '#00ff00', true);
            }
        }

        // Keep all your existing pathfinding and visualization functions
        function findPath() {
            console.log('üîç FindPath called with:', { startNode, destinationNode });
            
            if (!startNode || !destinationNode) {
                console.error('‚ùå Missing nodes:', { startNode, destinationNode });
                alert('Please select both starting point and destination');
                return;
            }

            if (!campusGraph) {
                console.error('‚ùå Campus graph not loaded');
                alert('Campus map data not loaded yet. Please wait and try again.');
                return;
            }

            if (!campusNodes) {
                console.error('‚ùå Campus nodes not loaded');
                alert('Campus node data not loaded yet. Please wait and try again.');
                return;
            }

            console.log('üîç Graph has nodes:', Object.keys(campusGraph).length);
            console.log('üîç Node data count:', campusNodes.length);
            console.log('üîç Start node in graph:', startNode in campusGraph);
            console.log('üîç Destination node in graph:', destinationNode in campusGraph);

            const path = astarPath(campusGraph, campusNodes, startNode, destinationNode);
            if (path && path.length > 0) {
                console.log('üõ§Ô∏è Path found:', path);
                drawPath(path);
                currentPath = path;
                
                const startNodeData = campusNodes.find(n => n.id === startNode);
                const endNodeData = campusNodes.find(n => n.id === destinationNode);
                const status = document.getElementById('status');
                status.textContent = `Route: ${startNodeData?.label || startNode} ‚Üí ${endNodeData?.label || destinationNode} (${path.length - 1} steps)`;
            } else {
                console.error('‚ùå No path found');
                console.log('üîç Debugging info:', {
                    startExists: campusNodes.find(n => n.id === startNode),
                    endExists: campusNodes.find(n => n.id === destinationNode),
                    startInGraph: startNode in campusGraph,
                    endInGraph: destinationNode in campusGraph
                });
                alert('No path found between selected locations');
            }
        }

        // Include all your existing pathfinding, animation, and interaction functions here
        // (astarPath, drawPath, createTravelingIcon, etc. - keeping them exactly as they are)
        
        function getNodeCoordinates(nodes, nodeId) {
            for (const node of nodes) {
                if (node.id === nodeId) {
                    return { x: node.x, y: node.y };
                }
            }
            return null;
        }

        function heuristicDistance(coord1, coord2) {
            const dx = coord2.x - coord1.x;
            const dy = coord2.y - coord1.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function astarPath(graph, nodes, start, end) {
            console.log(`üîç A* Pathfinding: ${start} ‚Üí ${end}`);
            
            const endCoords = getNodeCoordinates(nodes, end);
            const startCoords = getNodeCoordinates(nodes, start);
            
            if (!endCoords || !startCoords) {
                console.error('‚ùå Could not find coordinates:', { 
                    start, startCoords, 
                    end, endCoords 
                });
                return null;
            }

            if (!graph[start] || !graph[end]) {
                console.error('‚ùå Node not found in graph:', { 
                    start: start in graph, 
                    end: end in graph,
                    startConnections: graph[start] ? Object.keys(graph[start]).length : 0,
                    endConnections: graph[end] ? Object.keys(graph[end]).length : 0
                });
                return null;
            }

            console.log('‚úÖ Starting A* with valid nodes and coordinates');

            const gScore = {};
            const fScore = {};
            const previous = {};
            const openSet = new Set();
            const closedSet = new Set();

            for (const node in graph) {
                gScore[node] = Infinity;
                fScore[node] = Infinity;
                previous[node] = null;
            }

            gScore[start] = 0;
            fScore[start] = heuristicDistance(startCoords, endCoords);
            openSet.add(start);

            while (openSet.size > 0) {
                let current = null;
                let minFScore = Infinity;
                for (const node of openSet) {
                    if (fScore[node] < minFScore) {
                        minFScore = fScore[node];
                        current = node;
                    }
                }

                if (current === null) break;
                if (current === end) break;

                openSet.delete(current);
                closedSet.add(current);

                for (const neighbor in graph[current] || {}) {
                    if (closedSet.has(neighbor)) continue;
                    
                    const tentativeGScore = gScore[current] + graph[current][neighbor];
                    
                    if (!openSet.has(neighbor)) {
                        openSet.add(neighbor);
                    } else if (tentativeGScore >= gScore[neighbor]) {
                        continue;
                    }

                    previous[neighbor] = current;
                    gScore[neighbor] = tentativeGScore;
                    
                    const neighborCoords = getNodeCoordinates(nodes, neighbor);
                    if (neighborCoords) {
                        const hScore = heuristicDistance(neighborCoords, endCoords);
                        fScore[neighbor] = gScore[neighbor] + hScore;
                    }
                }
            }

            const path = [];
            let current = end;
            while (current !== null) {
                path.unshift(current);
                current = previous[current];
            }

            console.log('üõ§Ô∏è A* result:', {
                pathLength: path.length,
                pathValid: path.length > 1 && path[0] === start,
                path: path
            });

            return path.length > 1 && path[0] === start ? path : null;
        }

        function drawPath(path) {
            console.log('üé® Drawing path:', path);
            clearPath();
            
            const pathLayer = document.getElementById('path-layer');
            if (!pathLayer) {
                console.error('‚ùå Path layer not found');
                return;
            }
            
            if (path.length < 2) {
                console.error('‚ùå Path too short:', path.length);
                return;
            }

            console.log('üöÇ Creating path line...');

            const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
            
            const points = path.map(nodeId => {
                const node = campusNodes.find(n => n.id === nodeId);
                if (!node) {
                    console.error(`‚ùå Node not found: ${nodeId}`);
                    return null;
                }
                return `${node.x},${node.y}`;
            }).filter(point => point).join(' ');

            if (!points) {
                console.error('‚ùå No valid points for path');
                return;
            }

            pathElement.setAttribute('points', points);
            pathElement.setAttribute('class', 'path-line');
            pathElement.style.strokeDasharray = '0';
            pathElement.style.strokeDashoffset = '0';
            pathElement.style.opacity = '0.8';

            pathLayer.appendChild(pathElement);
            console.log('‚úÖ Path line created');

            // Create traveling icon
            const travelingIcon = createTravelingIcon(path);
            if (travelingIcon) {
                pathLayer.appendChild(travelingIcon);
                console.log('‚úÖ Traveling icon added');
                
                // Start animation
                setTimeout(() => {
                    animateTrainStyle(pathElement, travelingIcon, path);
                }, 100);
            }

            // Highlight nodes
            highlightNode(path[0], '#00ff00', true); // Start with pulse
            
            setTimeout(() => {
                highlightNode(path[path.length - 1], '#ff0000'); // End node
            }, 2000);

            console.log('üéâ Path drawing completed');
        }

        function highlightNode(nodeId, color, pulse = false) {
            const nodeElement = document.querySelector(`[data-id="${nodeId}"]`);
            if (nodeElement) {
                nodeElement.style.stroke = color;
                nodeElement.style.strokeWidth = '5';
                
                if (pulse) {
                    nodeElement.classList.add('start-node-pulse');
                }
            }
        }

        function clearPath() {
            const pathLayer = document.getElementById('path-layer');
            if (pathLayer) {
                pathLayer.innerHTML = '';
            }

            document.querySelectorAll('.node').forEach(node => {
                node.style.stroke = '#ffffff';
                node.style.strokeWidth = '3';
                node.classList.remove('start-node-pulse');
            });

            currentPath = [];
            startNode = null;
            destinationNode = null;
            
            // Clear panel inputs
            document.getElementById('fromInput').value = '';
            document.getElementById('toInput').value = '';
            
            const status = document.getElementById('status');
            status.textContent = 'Ready - Search or explore the campus!';
        }

        // Add all your existing zone, label, and zoom functions here
        
        function createTravelingIcon(path) {
            if (!path || path.length < 2) {
                console.error('‚ùå Invalid path for traveling icon');
                return null;
            }

            // Create a group for the navigation icon
            const iconGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            iconGroup.setAttribute('class', 'navigation-icon');
            
            // Create the main marker body (teardrop shape)
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            marker.setAttribute('d', 'M0,-20 C-10,-20 -15,-10 -15,0 C-15,10 0,20 0,20 C0,20 15,10 15,0 C15,-10 10,-20 0,-20 Z');
            marker.setAttribute('fill', '#2196F3');
            marker.setAttribute('stroke', '#1976D2');
            marker.setAttribute('stroke-width', '2');
            marker.style.filter = 'drop-shadow(0 2px 8px rgba(33, 150, 243, 0.4))';
            
            // Create inner circle (person/avatar)
            const avatar = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            avatar.setAttribute('cx', '0');
            avatar.setAttribute('cy', '-8');
            avatar.setAttribute('r', '6');
            avatar.setAttribute('fill', '#ffffff');
            avatar.setAttribute('stroke', '#1976D2');
            avatar.setAttribute('stroke-width', '1');
            
            // Create direction indicator (small triangle)
            const direction = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            direction.setAttribute('d', 'M0,-12 L-3,-6 L3,-6 Z');
            direction.setAttribute('fill', '#1976D2');
            
            // Add pulsing outer ring
            const pulseRing = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            pulseRing.setAttribute('cx', '0');
            pulseRing.setAttribute('cy', '0');
            pulseRing.setAttribute('r', '25');
            pulseRing.setAttribute('fill', 'none');
            pulseRing.setAttribute('stroke', '#2196F3');
            pulseRing.setAttribute('stroke-width', '2');
            pulseRing.setAttribute('opacity', '0.3');
            pulseRing.style.animation = 'navigation-pulse 2s ease-in-out infinite';
            
            // Assemble the icon
            iconGroup.appendChild(pulseRing);
            iconGroup.appendChild(marker);
            iconGroup.appendChild(avatar);
            iconGroup.appendChild(direction);
            
            // Position at start
            const startNode = campusNodes.find(n => n.id === path[0]);
            if (startNode) {
                iconGroup.setAttribute('transform', `translate(${startNode.x}, ${startNode.y})`);
            }
            
            console.log('‚úÖ Enhanced navigation icon created');
            return iconGroup;
        }

        function animateTrainStyle(pathElement, icon, path) {
            if (!pathElement || !icon || !path || path.length < 2) {
                console.error('‚ùå Invalid parameters for train animation');
                return;
            }

            console.log('üöÇ Starting slow navigation animation');
            
            let currentIndex = 0;
            const animationDuration = 1200; // Slower animation: 1200ms per segment
            
            // Initially hide the path line
            pathElement.style.strokeDasharray = '10 10';
            pathElement.style.strokeDashoffset = '20';
            pathElement.style.opacity = '0.3';

            function moveToNext() {
                if (currentIndex >= path.length - 1) {
                    console.log('üèÅ Navigation animation completed');
                    // Final completion effect
                    icon.style.animation = 'navigation-pulse 0.8s ease-in-out 3';
                    pathElement.style.opacity = '0.8';
                    pathElement.style.strokeDasharray = '0';
                    return;
                }

                const currentNode = campusNodes.find(n => n.id === path[currentIndex]);
                const nextNode = campusNodes.find(n => n.id === path[currentIndex + 1]);

                if (!currentNode || !nextNode) {
                    console.error(`‚ùå Node not found during animation: ${path[currentIndex]} -> ${path[currentIndex + 1]}`);
                    currentIndex++;
                    moveToNext();
                    return;
                }

                console.log(`ÔøΩ Walking from ${currentNode.id} to ${nextNode.id}`);

                // Smooth animation to next position using transform for the group
                icon.style.transition = `transform ${animationDuration}ms cubic-bezier(0.4, 0.0, 0.2, 1)`;
                icon.setAttribute('transform', `translate(${nextNode.x}, ${nextNode.y}) scale(1.1)`);
                
                // Return to normal scale after half animation  
                setTimeout(() => {
                    icon.setAttribute('transform', `translate(${nextNode.x}, ${nextNode.y}) scale(1.0)`);
                }, animationDuration / 2);

                // Progressive path revelation - draw the segment as icon moves
                const segment = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                segment.setAttribute('x1', currentNode.x);
                segment.setAttribute('y1', currentNode.y);
                segment.setAttribute('x2', currentNode.x); // Start at same point
                segment.setAttribute('y2', currentNode.y);
                segment.setAttribute('stroke', '#4CAF50');
                segment.setAttribute('stroke-width', '6');
                segment.setAttribute('stroke-linecap', 'round');
                segment.setAttribute('class', 'path-segment');
                segment.style.opacity = '0.9';
                segment.style.filter = 'drop-shadow(0 0 8px rgba(76, 175, 80, 0.5))';

                const pathLayer = document.getElementById('path-layer');
                if (pathLayer) {
                    pathLayer.appendChild(segment);
                    
                    // Animate the segment drawing
                    setTimeout(() => {
                        segment.style.transition = `x2 ${animationDuration}ms ease-out, y2 ${animationDuration}ms ease-out`;
                        segment.setAttribute('x2', nextNode.x);
                        segment.setAttribute('y2', nextNode.y);
                    }, 100);
                }

                currentIndex++;
                setTimeout(moveToNext, animationDuration);
            }

            moveToNext();
        }
        async function addInteractiveZones(svg) {
            return addInteractiveZonesForFloor(svg, './data/second_floor_zones.json');
        }

        async function addInteractiveZonesForFloor(svg, zonesPath) {
            console.log('üéØ Loading interactive zones from:', zonesPath);
            
            try {
                const cacheBuster = new Date().getTime();
                const response = await fetch(`${zonesPath}?v=${cacheBuster}`);
                if (!response.ok) {
                    throw new Error(`Failed to load zones: ${response.status}`);
                }
                const zonesData = await response.json();
                
                // Store zone data globally for use by other functions
                window.zoneData = zonesData;
                console.log('‚úÖ Zone data loaded and stored globally:', zonesData.length, 'zones');
                
                const zonesLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                zonesLayer.id = 'interactive-zones';
                zonesLayer.style.pointerEvents = 'auto';
                svg.appendChild(zonesLayer);
                
                createZoneInfoBox();
                
                zonesData.forEach(zone => {
                    addZoneToMap(zonesLayer, zone);
                });
                
                console.log('‚úÖ Interactive zones implemented');
                
            } catch (error) {
                console.error('‚ùå Error loading zones:', error);
                window.zoneData = null;
            }
        }

        function createZoneInfoBox() {
            const infoBox = document.createElement('div');
            infoBox.id = 'zone-info-box';
            document.body.appendChild(infoBox);
        }

        function addZoneToMap(zonesLayer, zone) {
            const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            
            const pointsString = zone.points.map(point => `${point[0]},${point[1]}`).join(' ');
            polygon.setAttribute('points', pointsString);
            polygon.setAttribute('fill', zone.fill);
            polygon.setAttribute('fill-opacity', '0.3');
            polygon.setAttribute('stroke', zone.fill);
            polygon.setAttribute('stroke-width', '2');
            polygon.setAttribute('stroke-opacity', '0.6');
            polygon.style.cursor = 'pointer';
            polygon.style.transition = 'all 0.3s ease';
            
            polygon.setAttribute('data-zone-id', zone.id);
            polygon.setAttribute('data-zone-category', zone.category);
            polygon.setAttribute('data-centroid-x', zone.centroid_x);
            polygon.setAttribute('data-centroid-y', zone.centroid_y);
            
            polygon.addEventListener('click', (event) => handleZoneClick(zone, event));
            
            zonesLayer.appendChild(polygon);
        }

        function handleZoneClick(zone, event) {
            const clickX = event.clientX;
            const clickY = event.clientY;
            
            showZoneInfo(zone, clickX, clickY);
        }

        function showZoneInfo(zone, clickX, clickY) {
            const infoBox = document.getElementById('zone-info-box');
            const nearestNode = findNearestNode(zone.centroid_x, zone.centroid_y);
            
            let displayName = zone.id.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            
            infoBox.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                    <h3 style="margin: 0; color: #333;">${displayName}</h3>
                    <button id="close-info-btn" style="background: none; border: none; font-size: 20px; cursor: pointer;">√ó</button>
                </div>
                <div style="margin-bottom: 16px;">
                    <p style="margin: 4px 0; color: #666;">Category: ${zone.category}</p>
                </div>
                <button id="set-destination-btn" style="width: 100%; padding: 10px; background: #007BFF; color: white; border: none; border-radius: 6px; cursor: pointer;">
                    Set as Destination
                </button>
            `;
            
            if (clickX !== undefined && clickY !== undefined) {
                infoBox.style.left = `${clickX + 10}px`;
                infoBox.style.top = `${clickY - 10}px`;
                infoBox.style.transform = 'none';
            }
            
            document.getElementById('set-destination-btn').addEventListener('click', () => {
                setZoneAsDestination(zone);
            });
            
            document.getElementById('close-info-btn').addEventListener('click', () => {
                infoBox.style.display = 'none';
            });
            
            infoBox.style.display = 'block';
        }

        function findNearestNode(x, y) {
            let nearestNode = null;
            let minDistance = Infinity;
            
            campusNodes.forEach(node => {
                if (node.searchable) {
                    const distance = Math.sqrt(
                        Math.pow(node.x - x, 2) + Math.pow(node.y - y, 2)
                    );
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestNode = node;
                    }
                }
            });
            
            return nearestNode;
        }

        function setZoneAsDestination(zone) {
            const nearestNode = findNearestNode(zone.centroid_x, zone.centroid_y);
            
            if (nearestNode) {
                // Set the destination in the panel
                destinationNode = nearestNode.id;
                document.getElementById('toInput').value = nearestNode.label;
                
                // Hide the info box
                document.getElementById('zone-info-box').style.display = 'none';
                
                // Open the directions panel
                const panel = document.getElementById('directionsPanel');
                panel.classList.add('open');
                
                // Focus on the from input for user to enter start location
                setTimeout(() => {
                    document.getElementById('fromInput').focus();
                }, 300);
                
                const status = document.getElementById('status');
                status.textContent = `Destination: ${nearestNode.label}. Please select start location.`;
            }
        }

        function showNodeLabel(node, event) {
            hideNodeLabel();
            
            const label = document.createElement('div');
            label.className = 'node-label';
            label.textContent = node.label || node.id;
            label.id = 'current-node-label';
            
            document.body.appendChild(label);
            updateLabelPosition(event);
        }

        function hideNodeLabel() {
            const existingLabel = document.getElementById('current-node-label');
            if (existingLabel) {
                existingLabel.remove();
            }
        }

        function updateLabelPosition(event) {
            const label = document.getElementById('current-node-label');
            if (label) {
                label.style.left = `${event.clientX}px`;
                label.style.top = `${event.clientY}px`;
            }
        }


    </script>
</body>
</html>
